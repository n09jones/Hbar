#include <iostream>
#include <boost/program_options.hpp>
#include "Job_Manager.h"
#include "Global_Info.h"
#include "File_IO.h"
#include "Program_Options_Wrapper.h"
#include "Template_Impl/Cluster_Implementations/SLURM_Impl.hpp"

using boost::filesystem::path;

/* Options for getting the options file name and for printing a template options file */
const std::vector<pow_nms::mob_desc> jm_nms::opts_fn_opts
{
    {"opts_fn", [](){return boost::program_options::value<std::string>();}, "Name of the options file"},
    {"print_opts_fn", [](){return boost::program_options::value<std::string>();}, "Print an options file template to the given path"},
    {"print_out_mem", [](){return boost::program_options::value<std::string>();}, "Print the total memory of the output files generated by running with the given options file"}
};

/* File option determining the number of partitions to use */
const std::vector<pow_nms::mob_desc> jm_nms::tot_parts_opt
{
    {"Total Partitions", [](){return (boost::program_options::value<size_t>()->default_value(1));}, "Break the job into this many parts"}
};

/* Command line options giving instructions for execution on the cluster */
const std::vector<pow_nms::mob_desc> jm_nms::vis_run_opts
{
    {"cluster", [](){return (boost::program_options::bool_switch()->default_value(false));}, "Run on the cluster; number of nodes is set by the number of partitions"},
    {"cluster_single", [](){return (boost::program_options::bool_switch()->default_value(false));}, "Run on the cluster; one node is used; run partitions sequentially"}
};

/* Command line options, which shouldn't be set by the user, determining which partition should be addressed */
const std::vector<pow_nms::mob_desc> jm_nms::hid_run_opts
{
    {"part_group_idx", [](){return (boost::program_options::value<size_t>());}, "Partition index / global_nms::max_arr_idx ***SHOULD ONLY BE SET BY THE PROGRAM***"},
    {"part_member_idx", [](){return (boost::program_options::value<size_t>());}, "Partition index % global_nms::max_arr_idx ***SHOULD ONLY BE SET BY THE PROGRAM***"}
};


/***************************/
/*     EXECUTE PROGRAM     */
/***************************/

/*
 Input:
 - argc: Number of command line arguments
 - argv: Command line arguments
 - main_fnc: Function for exec_prgrm
 - fn_pair_vec_func: Function that, given an options file path, generates fn_pair_vec for exec_prgrm
 - print_template_opts_fn: Function that prints a template options file to the input path
 - print_out_mem_func: Function that prints the total memory of the output files generated by running main_fnc with the input options file
 - extra_job_opts: Function that prints additional job options
 
 Function:
 - If certain command line arguments appear in argv, perform useful auxiliary tasks.
 - If an options file is given, run exec_prgrm.
 
 Output:
 - 0
 */
int jm_nms::pseudo_main(int argc, char ** argv, std::function<void(int, char**, size_t, size_t)> main_fnc, std::function<std::vector<std::pair<path, bool>>(const path&)> fn_pair_vec_func, std::function<void(const path&)> print_template_opts_fn, std::function<void(const path&)> print_out_mem_func, std::function<void()> extra_job_opts)
{
    boost::program_options::variables_map vm {pow_nms::get_cmd_opt(argc, argv, opts_fn_opts)};
    pow_nms::dep_opts({{vm, "print_out_mem"}, {vm, "print_opts_fn"}, {vm, "opts_fn"}}, pow_nms::opt_dep::excl);
    
    if(vm.count("print_out_mem")) {
        print_out_mem_func(vm["print_out_mem"].as<std::string>());
        std::cout << std::endl;
    }
    else if(vm.count("print_opts_fn")) {
        print_template_opts_fn(vm["print_opts_fn"].as<std::string>());
    }
    else if(vm.count("opts_fn")) {
        exec_prgrm(argc, argv, main_fnc, fn_pair_vec_func(get_opts_fn(argc, argv)));
    }
    else {
        print_job_opts();
        extra_job_opts();
    }
    
    return 0;
}


/*
 Input:
 - argc: Number of command line arguments
 - argv: Command line arguments
 - main_fnc: Function (argc, argv, tot_parts, part_idx) that needs to be executed for each partition index (last argument)
 - fn_pair_vec: Vector of (path, is path a vector base path? boolean) pairs for concatonated file paths
 
 Function:
 - Print a message and return if all files corresponding to fn_pair_vec exist.
 - If not, run main_fnc for the necessary partition indices and concatonate the results.
 - All operations are run in the locations specified by the command line options.
 
 Output:
 - None
 */
void jm_nms::exec_prgrm(int argc, char ** argv, std::function<void(int, char**, size_t, size_t)> main_fnc, const std::vector<std::pair<path, bool>>& fn_pair_vec)
{
    if(!fio_nms::clear_incomplete_file_set(fn_pair_vec)) {
        (std::cout << "Job complete" << std::endl);
        return;
    }
    
    boost::program_options::variables_map vm {pow_nms::get_file_opt_from_cmd(argc, argv, tot_parts_opt)};
    size_t tot_parts {vm["Total Partitions"].as<size_t>()};
    
    switch(get_exec_loc(argc, argv)) {
        case exec_loc::loc :
            for(size_t part_idx: fio_nms::missing_part_files(fn_pair_vec, tot_parts)) {
                main_fnc(argc, argv, tot_parts, part_idx);
            }
            fio_nms::cat_part_files(fn_pair_vec, tot_parts);
            break;
            
        case exec_loc::loc_part_calc :
            main_fnc(argc, argv, tot_parts, get_part_idx(argc, argv));
            break;
            
        case exec_loc::cluster :
        {
            std::list<std::list<std::pair<size_t, size_t>>> loc_miss_ints = miss_ints(fn_pair_vec, tot_parts);
            if(loc_miss_ints.empty()) {submit_single_job(argc, argv);}
            else {submit_batch_job(argc, argv, loc_miss_ints);}
        }
            break;
            
        case exec_loc::cluster_single :
            submit_single_job(argc, argv);
            break;
    }
}




/*********************************/
/*     GET EXECUTION OPTIONS     */
/*********************************/

/*
 Inputs:
 - argc: Number of command line arguments
 - argv: Command line arguments
 
 Function:
 - Parse argv to determine how the program ought to be executed.
 
 Output:
 - Enum giving information on how to execute the program
 */
jm_nms::exec_loc jm_nms::get_exec_loc(int argc, char ** argv)
{
    boost::program_options::variables_map vm {pow_nms::get_cmd_opt(argc, argv, {hid_run_opts, vis_run_opts})};
    
    pow_nms::dep_opts({{vm, "cluster"}, {vm, "cluster_single"}, {vm, "part_group_idx"}}, pow_nms::opt_dep::excl);
    pow_nms::dep_opts({{vm, "part_group_idx"}, {vm, "part_member_idx"}}, pow_nms::opt_dep::bound);
    
    if(vm.count("part_group_idx")) {return exec_loc::loc_part_calc;}
    if(vm["cluster"].as<bool>()) {return exec_loc::cluster;};
    if(vm["cluster_single"].as<bool>()) {return exec_loc::cluster_single;}
    return exec_loc::loc;
}


/*
 Inputs:
 - argc: Number of command line arguments
 - argv: Command line arguments
 
 Function:
 - Parse argv to determine the partition index of interest.
 
 Output:
 - Partition index of interest
 */
size_t jm_nms::get_part_idx(int argc, char ** argv)
{
    boost::program_options::variables_map vm {pow_nms::get_cmd_opt(argc, argv, jm_nms::hid_run_opts)};
    return ((vm["part_group_idx"].as<size_t>()*global_nms::max_arr_idx) + vm["part_member_idx"].as<size_t>());
}


/*
 Inputs:
 - argc: Number of command line arguments
 - argv: Command line arguments
 
 Function:
 - Get the options file's path from the command line.
 
 Output:
 - Options file path
 */
path jm_nms::get_opts_fn(int argc, char ** argv)
{
    boost::program_options::variables_map vm {pow_nms::get_cmd_opt(argc, argv, opts_fn_opts)};
    return vm.at("opts_fn").as<std::string>();
}




/******************************/
/*     GET NEXT JOBS LIST     */
/******************************/


/*
 Inputs:
 - nums: Ordered (ascending) list of unsigned integers
 
 Function:
 - Construct a list consisting of the intervals appearing in nums.
 
 Output:
 - Constructed list
 */
std::list<std::pair<size_t, size_t>> jm_nms::extract_intervals(std::list<size_t> nums)
{
    if(!is_sorted(nums.begin(), nums.end())) {throw jm_exc{"Input must already be sorted"};}
    std::list<std::pair<size_t, size_t>> intervals {};
    
    for(const size_t& x: nums) {
        if(intervals.size() && (intervals.back().second + 1 == x)) {intervals.back().second++;}
        else {intervals.push_back({x, x});}
    }
    
    return intervals;
}


/*
 Inputs:
 - fn_pair_vec: Vector of (path, is path a vector base path? boolean) pairs for concatonated file paths
 - tot_parts: Number of partitions
 
 Function:
 - Determine which jobs in part still need to be done.
 - Select no more than jobs_left of these, and decrease jobs_left by the number of unfinished jobs selected.
 - Construct a list of lists of intervals. Each list of intervals corresponds to selected unfinished jobs of a single group index.
 
 Output:
 - Constructed list of lists of intervals
 */
std::list<std::list<std::pair<size_t, size_t>>> jm_nms::miss_ints(const std::vector<std::pair<path, bool>>& fn_pair_vec, size_t tot_parts)
{
    static size_t jobs_left {global_nms::max_jobs};
    std::list<size_t> miss_idx {fio_nms::missing_part_files(fn_pair_vec, tot_parts)};
    if(miss_idx.size() > jobs_left) {miss_idx.resize(jobs_left);}
    jobs_left -= miss_idx.size();
    
    std::list<std::list<std::pair<size_t, size_t>>> miss_ints {};
    
    while (miss_idx.size()) {
        auto end_it = upper_bound(miss_idx.begin(), miss_idx.end(), (((miss_idx.front()/global_nms::max_arr_idx) + 1)*global_nms::max_arr_idx) - 1);
        miss_ints.push_back(extract_intervals(std::list<size_t>{miss_idx.begin(), end_it}));
        miss_idx.erase(miss_idx.begin(), end_it);
    }
    
    return miss_ints;
}




/*****************************/
/*     PRINT JOB OPTIONS     */
/*****************************/

/*
 Inputs:
 - None
 
 Function:
 - Print options to the command line.
 
 Output:
 - None
 */
void jm_nms::print_job_opts()
{
    std::cout << std::endl;
    boost::program_options::options_description desc_po {"Program Options"};
    std::cout << pow_nms::append_desc_vec(desc_po, opts_fn_opts) << std::endl;
    
    boost::program_options::options_description desc_cmd {"Run Options"};
    pow_nms::append_desc_vec(desc_cmd, vis_run_opts);
    std::cout << desc_cmd << std::endl;
    
    boost::program_options::options_description desc_opt_file {"Options File Options (Not Required)"};
    pow_nms::append_desc_vec(desc_opt_file, tot_parts_opt);
    pow_nms::append_desc_vec(desc_opt_file, Impl_opts);
    std::cout << desc_opt_file << std::endl;
}

