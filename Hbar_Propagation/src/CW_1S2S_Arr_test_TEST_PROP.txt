#include <iostream>
#include <chrono>
#include "ATRAP_base.h"
#include "ATRAP_Atomic_Physics.h"

double time_time;

constexpr pdef_nms::illum_type it_const {pdef_nms::illum_type::TwoPh};

using EM_Quant_Gen = emq_nms::grid_EM_quants<ig_nms::interp_type::lin>;

using kh_t = kin_hand_nms::kinematic_handler<true, boost::numeric::odeint::symplectic_rkn_sb3a_mclachlan<bvec_nms::basic_vec<>, bvec_nms::basic_vec<>, global_nms::default_data_type, bvec_nms::basic_vec<>, bvec_nms::basic_vec<>, double, boost::numeric::odeint::vector_space_algebra>, 0, EM_Quant_Gen>;

using ill_t = ill_arr_hand_nms::illumination_array_handler<it_const, EM_Quant_Gen>;
using dec_t = decay_arr_nms::decay_array_handler<it_const, EM_Quant_Gen>;
using ssah_t = st_sum_arr_hand_nms::st_sum_arr_hand;
using aaeh_t = aae_hand_nms::atomic_array_evolution_handler<ill_t, dec_t, ssah_t>;

using func_ptr_t = void (*)(kh_t&, aaeh_t&);
func_ptr_t next_func {nullptr};

template <ig_nms::interp_quant IQ> void run_reg(kh_t& kh, aaeh_t& aaeh);
template <ig_nms::interp_quant IQ> void in_beam_func(kh_t& kh, aaeh_t& aaeh);


template <ig_nms::interp_quant IQ>
void run_reg(kh_t& kh, aaeh_t& aaeh)
{
    for(; ((kh.t < kh.t_lim) && !(kh.out_of_bounds()) && !(aaeh.in_beam(kh.pos_vel))); kh.t += kh.dt) {
while(kh.t >= time_time) {std::cout << "t = " << kh.t << ", " << prop_num << " of " << poss_num << std::endl; ++time_time;}
        kh.template do_step<IQ>();
    }
    
    if((kh.t >= kh.t_lim) || kh.out_of_bounds()) {next_func = nullptr;}
    else {next_func = in_beam_func<IQ>;}
}

template <ig_nms::interp_quant IQ>
void in_beam_func(kh_t& kh, aaeh_t& aaeh)
{
    aaeh.initialize();
    kh.dt = aaeh.dt;
    
    for(auto& elem : aaeh.ill.decay_threshold_vec) {elem = -1.0;}
    for(auto& elem : aaeh.ill.excitation_threshold_vec) {elem = -1.0;}

    aaeh.build_params_arr<IQ>(kh);

size_t len {aaeh.params_arr_len};

for(size_t idx = 0; idx < len; ++idx)
{
    kh.final_states.push_back({});
    kh.final_states.back().pos_vel = aaeh.pos_arr[idx];
    kh.final_states.push_back({});
    auto& ref {aaeh.params_arr[idx]};
    kh.final_states.back().pos_vel.first[0] = ref[0].real();
    kh.final_states.back().pos_vel.first[1] = ref[0].imag();
    kh.final_states.back().pos_vel.first[2] = ref[1].real();
    kh.final_states.back().pos_vel.second[0] = ref[1].imag();
    kh.final_states.back().pos_vel.second[1] = ref[2].real();
    kh.final_states.back().pos_vel.second[2] = ref[2].imag();
}

kh.final_states.push_back({});
kh.final_states.back().pos_vel.first[0] = -1.0;
kh.final_states.back().pos_vel.first[1] = -1.0;
kh.final_states.back().pos_vel.first[2] = -1.0;
kh.final_states.back().pos_vel.second[0] = -1.0;
kh.final_states.back().pos_vel.second[1] = -1.0;
kh.final_states.back().pos_vel.second[2] = -1.0;

auto tmp_params_arr {aaeh.params_arr};
auto tmp_pos_arr {aaeh.pos_arr};

for(size_t idx = 0; idx < len; ++idx)
{
    aaeh.params_arr_len = 1;
    aaeh.params_arr[0] = tmp_params_arr[idx];
    aaeh.pos_arr[0] = tmp_pos_arr[idx];
    aaeh.do_steps<IQ>(kh);
    auto& ref_2 {aaeh.ill.d_mat_vec};
    kh.final_states.push_back({});
    kh.final_states.back().pos_vel.first[0] = ref_2[0][0].real(); 
    kh.final_states.back().pos_vel.first[1] = ref_2[0][0].imag(); 
    kh.final_states.back().pos_vel.first[2] = ref_2[0][1].real(); 
    kh.final_states.back().pos_vel.second[0] = ref_2[0][1].imag(); 
    kh.final_states.back().pos_vel.second[1] = ref_2[1][0].real(); 
    kh.final_states.back().pos_vel.second[2] = ref_2[1][0].imag(); 
    kh.final_states.push_back({});
    kh.final_states.back().pos_vel.first[0] = ref_2[1][1].real(); 
    kh.final_states.back().pos_vel.first[1] = ref_2[1][1].imag(); 
    kh.final_states.back().pos_vel.first[2] = ref_2[2][0].real(); 
    kh.final_states.back().pos_vel.second[0] = ref_2[2][0].imag(); 
    kh.final_states.back().pos_vel.second[1] = ref_2[2][1].real(); 
    kh.final_states.back().pos_vel.second[2] = ref_2[2][1].imag(); 
}
    
    next_func = nullptr;    
}

void pick_and_run_sum(kh_t& kh, aaeh_t& aaeh, size_t IC_idx)
{
    kh.pos_vel = kh.ICs[IC_idx].pos_vel;
    kh.reset_out_of_bnds();
    kh.t = 0.0;

    kh.pos_vel.first = aaeh.ill.paths[0].focus;
    for(auto& elem : kh.pos_vel.second) {elem *= 0.1;}

    if(kh.gr_state == asts_nms::S_gr{{{"F", 1}, {"mF", 0}}}) {
        for(next_func = in_beam_func<ig_nms::interp_quant::acc_1Sc>; next_func;) {next_func(kh, aaeh);}
    }
    else if(kh.gr_state == asts_nms::S_gr{{{"F", 1}, {"mF", -1}}}) {
        for(next_func = in_beam_func<ig_nms::interp_quant::acc_1Sd>; next_func;) {next_func(kh, aaeh);}
    }
    else {
        throw kin_hand_nms::kin_hand_exc{"Not a trappable state"};
    }
}

void generate_ICs(int argc, char ** argv, size_t tot_parts, size_t part_idx)
{
    kh_t kh;
    aaeh_t aaeh;
    std::array<int, 3> det_lims {{218, 418, 100}};
    
    kh.fill(jm_nms::get_opts_fn(argc, argv), tot_parts, part_idx);
    
    std::cout << "Loaded" << std::endl;
    std::cout <<  "Minimum B : " << kh.Bnorm_min << std::endl;
    
    for(size_t IC_idx = 0; IC_idx < 1; ++IC_idx)
    {
time_time = 0.0;
     	aaeh.fill(jm_nms::get_opts_fn(argc, argv), det_lims);
        auto wcts = std::chrono::system_clock::now();
        std::cout << "Starting simulation for particle " << (IC_idx+1) << " of " << kh.ICs.size() << std::endl;

        pick_and_run_sum(kh, aaeh, IC_idx);

        std::chrono::duration<double> wctduration = (std::chrono::system_clock::now() - wcts);
        std::cout << "Finished " << kh.t_lim << " s of simulation time in " << wctduration.count() << " s of real time" << std::endl;
    }
    
    kh.print_contents();
}

int main(int argc, char ** argv)
{
try
{
    jm_nms::pseudo_main(argc, argv, generate_ICs, kh_t::output_files, kh_t::write_opt_file_template, kh_t::print_out_mem);
}
catch(gqt_nms::gqt_exc& exc) {
std::cout << exc.give_err() << std::endl;
}    
    return 0;
}

